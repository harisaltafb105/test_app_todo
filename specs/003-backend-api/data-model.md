# Data Model: Backend API with Authentication

**Feature**: 003-backend-api
**Date**: 2026-01-07
**Phase**: Phase 1 - Design

## Overview

This document defines the database schema for the Todo application backend using SQLModel ORM with Neon PostgreSQL. The schema enforces strict user isolation through foreign key relationships and indexes optimized for multi-tenant queries.

---

## Entity: Task

### Purpose

Represents a user's todo item with title, description, completion status, and audit timestamps. All tasks are scoped to a specific user via `user_id` foreign key.

### Table Definition

**Table Name**: `tasks`

**SQLModel Class**:
```python
from sqlmodel import Field, SQLModel
from sqlalchemy import Column, DateTime, func, Index
from datetime import datetime
from uuid import UUID, uuid4

class Task(SQLModel, table=True):
    """Task model representing a user's todo item."""

    __tablename__ = "tasks"

    # Primary key
    id: UUID = Field(
        default_factory=uuid4,
        primary_key=True,
        description="Unique task identifier"
    )

    # Core fields
    title: str = Field(
        max_length=500,
        nullable=False,
        description="Task title (required, max 500 chars)"
    )

    description: str | None = Field(
        default=None,
        max_length=5000,
        description="Task description (optional, max 5000 chars)"
    )

    completed: bool = Field(
        default=False,
        nullable=False,
        description="Task completion status"
    )

    # Audit timestamps
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column=Column(
            DateTime(timezone=True),
            nullable=False,
            server_default=func.now()
        ),
        description="Task creation timestamp"
    )

    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column=Column(
            DateTime(timezone=True),
            nullable=False,
            server_default=func.now(),
            onupdate=func.now()
        ),
        description="Task last update timestamp"
    )

    # User association (foreign key to Better Auth user)
    user_id: str = Field(
        nullable=False,
        index=True,
        description="User ID from Better Auth JWT token"
    )

    # Indexes
    __table_args__ = (
        Index("idx_user_created", "user_id", "created_at"),  # For sorted listings
    )
```

### Fields

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, NOT NULL | Auto-generated unique identifier |
| `title` | VARCHAR(500) | NOT NULL | Task title (required) |
| `description` | VARCHAR(5000) | NULLABLE | Task description (optional) |
| `completed` | BOOLEAN | NOT NULL, DEFAULT FALSE | Completion status |
| `created_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | Creation timestamp |
| `updated_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW(), ON UPDATE NOW() | Last update timestamp |
| `user_id` | VARCHAR | NOT NULL, INDEXED | Foreign key to Better Auth user |

### Relationships

**User Reference** (External):
- `user_id` references User entity managed by Better Auth (not stored in backend database)
- One-to-many: One user has many tasks
- Cascade: Tasks are isolated per user (no cascade delete - handled by application logic)

### Indexes

1. **Primary Index**: `id` (UUID, clustered)
   - **Purpose**: Fast lookups by task ID
   - **Query**: `SELECT * FROM tasks WHERE id = ?`

2. **User Index**: `user_id` (B-tree)
   - **Purpose**: Fast filtering by user
   - **Query**: `SELECT * FROM tasks WHERE user_id = ?`

3. **Composite Index**: `(user_id, created_at)` (B-tree)
   - **Purpose**: Fast sorted listings for user's tasks
   - **Query**: `SELECT * FROM tasks WHERE user_id = ? ORDER BY created_at DESC`

### Validation Rules

**Field Validation** (from FR-011):
- `title`:
  - Required (NOT NULL)
  - Length: 1-500 characters
  - Validation error if empty or > 500 chars
- `description`:
  - Optional (NULLABLE)
  - Length: 0-5000 characters
  - Validation error if > 5000 chars
- `completed`:
  - Required (NOT NULL)
  - Type: Boolean only (not string "true"/"false" or int 0/1)
  - Validation error if not boolean
- `user_id`:
  - Required (NOT NULL)
  - Must match JWT token user_id
  - Validation error if mismatch (403 Forbidden)

**Business Logic Validation**:
- User can only create tasks with their own `user_id`
- User can only read/update/delete tasks where `user_id` matches JWT token
- Tasks cannot be transferred between users

### State Transitions

**New Task** (POST /api/{user_id}/tasks):
```
Initial State:
  id = <auto-generated UUID>
  title = <from request>
  description = <from request or NULL>
  completed = FALSE
  created_at = NOW()
  updated_at = NOW()
  user_id = <from JWT token>
```

**Update Task** (PUT/PATCH /api/{user_id}/tasks/{task_id}):
```
State Changes:
  title = <from request> (if provided)
  description = <from request> (if provided)
  completed = <from request> (if provided)
  updated_at = NOW() (automatic)
```

**Toggle Completion** (PATCH with completed field):
```
State Transition:
  completed: FALSE → TRUE (mark complete)
  completed: TRUE → FALSE (mark incomplete)
  updated_at = NOW() (automatic)
```

**Delete Task** (DELETE /api/{user_id}/tasks/{task_id}):
```
State Transition:
  Task removed from database (hard delete)
  No soft delete or archive
```

### Database Constraints

**SQL DDL** (for reference):
```sql
CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    description VARCHAR(5000),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    user_id VARCHAR NOT NULL
);

-- Indexes
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_user_created ON tasks(user_id, created_at);

-- Trigger for updated_at (if not handled by ORM)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**Note**: SQLModel with `onupdate=func.now()` handles `updated_at` automatically, so trigger is optional.

---

## Entity: User (Reference Only)

### Purpose

Represents an authenticated user managed by Better Auth. Not stored in backend database - only referenced via `user_id` in Task table.

### Fields

| Field | Type | Source | Description |
|-------|------|--------|-------------|
| `id` | String | JWT `sub` or `userId` claim | Unique user identifier |
| `email` | String | JWT claims (optional) | User email address |
| `name` | String | JWT claims (optional) | User display name |

### Notes

- User table does NOT exist in backend database
- User data is managed by Better Auth in frontend
- Backend only stores `user_id` as string reference in Task table
- User ID is extracted from JWT token on every request
- No user CRUD endpoints in backend (all handled by Better Auth)

---

## Request/Response Schemas

### Task Response Schema

**Pydantic Model**:
```python
from pydantic import BaseModel, Field
from uuid import UUID
from datetime import datetime

class TaskResponse(BaseModel):
    """Task response schema matching frontend API client expectations."""

    id: UUID = Field(..., description="Task ID")
    title: str = Field(..., max_length=500, description="Task title")
    description: str | None = Field(None, max_length=5000, description="Task description")
    completed: bool = Field(..., description="Completion status")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    user_id: str = Field(..., description="Owner user ID")

    class Config:
        from_attributes = True  # Enable ORM mode for SQLModel compatibility
```

### Task Create Schema

**Pydantic Model**:
```python
class TaskCreate(BaseModel):
    """Task creation request schema."""

    title: str = Field(..., min_length=1, max_length=500, description="Task title (required)")
    description: str | None = Field(None, max_length=5000, description="Task description (optional)")

    # completed is NOT in create schema (defaults to False)
    # user_id is NOT in create schema (comes from JWT token)
```

### Task Update Schema (PUT)

**Pydantic Model**:
```python
class TaskUpdate(BaseModel):
    """Task full update request schema (PUT)."""

    title: str = Field(..., min_length=1, max_length=500, description="Task title (required)")
    description: str | None = Field(None, max_length=5000, description="Task description (optional)")
    completed: bool = Field(..., description="Completion status (required)")
```

### Task Partial Update Schema (PATCH)

**Pydantic Model**:
```python
class TaskPatch(BaseModel):
    """Task partial update request schema (PATCH)."""

    title: str | None = Field(None, min_length=1, max_length=500, description="Task title (optional)")
    description: str | None = Field(None, max_length=5000, description="Task description (optional)")
    completed: bool | None = Field(None, description="Completion status (optional)")
```

---

## Migration Strategy

### Initial Schema Creation

**Method**: SQLModel `metadata.create_all()` on application startup

**Implementation**:
```python
# database.py
from sqlmodel import SQLModel

async def create_db_and_tables():
    """Create database tables on application startup."""
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)
```

**Startup Hook**:
```python
# main.py
@app.on_event("startup")
async def on_startup():
    await create_db_and_tables()
```

### Future Migrations

**Method**: Alembic (for production schema changes)

**Setup** (when needed):
```bash
# Install Alembic
uv add alembic

# Initialize Alembic
alembic init migrations

# Generate migration
alembic revision --autogenerate -m "Add new field"

# Apply migration
alembic upgrade head
```

**Note**: For MVP, `create_all()` is sufficient. Switch to Alembic for production schema evolution.

---

## Data Integrity Guarantees

### User Isolation

**Enforcement Layers**:
1. **Application Layer**: Endpoint handlers verify `user_id` from URL matches JWT token (403 if mismatch)
2. **Query Layer**: All SELECT queries include `WHERE user_id = ?` filter
3. **Database Layer**: Index on `user_id` enforces fast filtering

**Test Coverage** (TC-003):
- User A cannot read User B's tasks
- User A cannot update User B's tasks
- User A cannot delete User B's tasks

### Referential Integrity

**User Reference**:
- `user_id` is string reference to Better Auth user (not enforced by foreign key constraint)
- Application validates user exists via JWT token verification
- Orphaned tasks (user deleted in Better Auth) remain in database (application decision)

**Cleanup Strategy**:
- Manual cleanup script if needed: `DELETE FROM tasks WHERE user_id = ?`
- Consider soft delete with `deleted_at` timestamp if required in future

---

## Performance Considerations

### Query Optimization

**List Tasks** (GET /api/{user_id}/tasks):
```sql
-- Optimized query using composite index
SELECT * FROM tasks
WHERE user_id = ?
ORDER BY created_at DESC;
-- Uses idx_user_created composite index
```

**Get Task** (GET /api/{user_id}/tasks/{task_id}):
```sql
-- Optimized query using primary key and user_id filter
SELECT * FROM tasks
WHERE id = ? AND user_id = ?;
-- Uses primary index on id + user_id filter
```

### Expected Performance

- **List Tasks**: < 50ms for 1000 tasks per user (using composite index)
- **Get/Create/Update/Delete Task**: < 20ms (using primary key index)
- **Concurrent Requests**: Async engine handles 100+ concurrent requests with connection pool

---

## Summary

**Tables**: 1 (tasks)
**Foreign Keys**: 1 (user_id references Better Auth user)
**Indexes**: 3 (primary key, user_id, composite user_id+created_at)
**Validation**: Pydantic schemas for request/response
**Migration**: SQLModel create_all() for MVP, Alembic for production

**Data Model Status**: ✅ Complete and ready for implementation
