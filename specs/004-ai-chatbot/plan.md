# Implementation Plan: Phase III AI-Powered Todo Chatbot

**Branch**: `004-ai-chatbot` | **Date**: 2026-01-14 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-ai-chatbot/spec.md`

## Summary

Integrate an AI-powered chatbot into the existing Phase II Todo application that enables users to manage tasks via natural language. The chatbot uses OpenAI Agents SDK with MCP tools for task operations, persists conversations to Neon PostgreSQL, and provides a non-intrusive chat UI via floating button and drawer.

**Key Technical Approach**:
- Stateless agent instantiated per request
- MCP tools wrap existing CRUD logic with user isolation
- New database tables (conversations, messages, tool_calls) are additive
- Frontend chat UI integrated via floating button + drawer

## Technical Context

**Language/Version**: Python 3.13+ (backend), TypeScript (frontend)
**Primary Dependencies**: FastAPI, OpenAI Agents SDK, MCP SDK, SQLModel, Next.js 16+, ChatKit
**Storage**: Neon Serverless PostgreSQL (existing + 3 new tables)
**Testing**: pytest (backend), manual (frontend for MVP)
**Target Platform**: Web application (desktop + mobile responsive)
**Project Type**: Web application (monorepo with backend/ and frontend/)
**Performance Goals**: Chat response < 5s, task list < 3s
**Constraints**: Stateless server, user isolation enforced, Phase II unchanged
**Scale/Scope**: Single user per session, up to 100 messages per conversation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Check | Status |
|-----------|-------|--------|
| I. Spec-Driven Development | All work references this spec | ✅ PASS |
| II. Multi-Tenant User Isolation | All tools validate user_id from JWT | ✅ PASS |
| III. JWT Authentication Bridge | Chat endpoint uses existing Better Auth JWT | ✅ PASS |
| IV. Monorepo with Clear Boundaries | Chatbot code isolated in backend/chat/, frontend/components/chat/ | ✅ PASS |
| V. API-First Design | Chat endpoint contract defined in contracts/chat-api.yaml | ✅ PASS |
| VI. Database Schema Integrity | New tables use SQLModel, user_id indexed | ✅ PASS |
| VII. Phase III Additive Extension | No Phase II modifications, chatbot detachable | ✅ PASS |
| VIII. Architectural Authority | Agent → MCP → FastAPI → DB chain enforced | ✅ PASS |
| IX. Stateless Server Law | Agent per request, state in DB only | ✅ PASS |
| X. MCP Tool Sovereignty | 5 single-purpose tools, user validation | ✅ PASS |
| XI. Agent Behavior Constraints | Tool-only execution, confirmation required | ✅ PASS |
| XII. Data Integrity & Safety | Transactional writes, error handling | ✅ PASS |
| XIII. Final Constitutional Law | AI is assistant, backend is authority | ✅ PASS |

**Gate Status**: ✅ ALL PRINCIPLES PASS - Proceed to implementation

## Project Structure

### Documentation (this feature)

```text
specs/004-ai-chatbot/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Phase 0 research findings
├── data-model.md        # Database schema (Conversation, Message, ToolCall)
├── quickstart.md        # Development setup guide
├── contracts/
│   ├── chat-api.yaml    # OpenAPI contract for chat endpoints
│   └── mcp-tools.md     # MCP tool interface contracts
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── models.py           # Add Conversation, Message, ToolCall models
│   ├── schemas.py          # Add chat request/response schemas
│   ├── routers/
│   │   ├── tasks.py        # Existing (unchanged)
│   │   └── chat.py         # NEW: Chat endpoint router
│   ├── chat/
│   │   ├── __init__.py
│   │   ├── agent.py        # OpenAI agent configuration
│   │   ├── tools.py        # MCP tool implementations
│   │   └── service.py      # Chat service layer
│   └── database.py         # Existing (models auto-registered)
├── tests/
│   ├── test_chat.py        # Chat endpoint tests
│   └── test_tools.py       # MCP tool tests
└── pyproject.toml          # Add openai, mcp dependencies

frontend/
├── src/
│   ├── components/
│   │   ├── chat/
│   │   │   ├── ChatButton.tsx    # Floating chat icon
│   │   │   ├── ChatDrawer.tsx    # Slide-out chat panel
│   │   │   ├── ChatMessages.tsx  # Message list component
│   │   │   └── ChatInput.tsx     # Message input component
│   │   └── ...existing components
│   ├── app/
│   │   └── layout.tsx      # Add ChatButton to layout
│   └── lib/
│       └── chat-api.ts     # Chat API client
└── package.json            # Add chatkit or AI SDK
```

**Structure Decision**: Web application with backend/ and frontend/ directories. Chatbot code isolated in dedicated subdirectories (backend/chat/, frontend/components/chat/) for modularity and potential removal.

## Implementation Phases

### Phase 1: Database Schema Extension

**Goal**: Add conversation persistence tables without breaking Phase II

**Tasks**:
1. Add SQLModel classes to `backend/models.py`:
   - `Conversation` with user_id, timestamps
   - `Message` with role, content, conversation_id
   - `ToolCall` with tool_name, parameters, result, message_id
2. Add Pydantic schemas to `backend/schemas.py`:
   - `ChatRequest`, `ChatResponse`, `ToolCallResponse`
3. Verify tables created on startup via `create_all()`
4. Test migration rollback script

**Outputs**: 3 new database tables, request/response schemas

---

### Phase 2: MCP Tool Implementation

**Goal**: Create stateless MCP tools that wrap existing CRUD logic

**Tasks**:
1. Create `backend/chat/tools.py` with tool implementations:
   - `add_task(params, context)` → Create task
   - `list_tasks(params, context)` → Read tasks with filtering
   - `update_task(params, context)` → Update task title/description
   - `complete_task(params, context)` → Toggle completion
   - `delete_task(params, context)` → Remove task
2. Each tool:
   - Receives `user_id` from context (not params)
   - Uses existing SQLModel queries
   - Returns standardized result/error format
3. Create tool registry for agent registration
4. Write unit tests for each tool

**Outputs**: 5 MCP tools with user isolation, tool registry

---

### Phase 3: OpenAI Agent Configuration

**Goal**: Configure stateless AI agent with tool bindings

**Tasks**:
1. Create `backend/chat/agent.py`:
   - Initialize OpenAI client with API key
   - Define agent system instructions
   - Register MCP tools as functions
   - Create `run_agent(message, history, context)` function
2. Define agent behavior:
   - Confirm actions before execution
   - Ask for clarification when ambiguous
   - Generate user-friendly responses
3. Implement conversation history loading
4. Test agent with mock tools

**Outputs**: Agent configuration, execution function

---

### Phase 4: Chat API Endpoint

**Goal**: Create stateless chat endpoint with persistence

**Tasks**:
1. Create `backend/routers/chat.py`:
   - `POST /{user_id}/chat` - Send message
   - `GET /{user_id}/conversations` - List conversations
   - `GET /{user_id}/conversations/{id}` - Get history
   - `DELETE /{user_id}/conversations/{id}` - Delete conversation
2. Implement chat service in `backend/chat/service.py`:
   - Create or load conversation
   - Store user message
   - Run agent with history
   - Store assistant response + tool calls
   - Return response
3. Add router to `main.py`
4. Write endpoint tests

**Outputs**: Chat router with 4 endpoints, chat service

---

### Phase 5: Frontend Chat Button & Drawer

**Goal**: Add non-intrusive chat UI entry point

**Tasks**:
1. Create `frontend/components/chat/ChatButton.tsx`:
   - Fixed position bottom-right
   - Click toggles drawer open/closed
   - Show only when authenticated
2. Create `frontend/components/chat/ChatDrawer.tsx`:
   - Slide-out panel from right
   - Close button and overlay
   - Responsive (full-screen on mobile)
3. Add ChatButton to `app/layout.tsx`
4. Test open/close behavior

**Outputs**: ChatButton, ChatDrawer components in layout

---

### Phase 6: Chat Message Components

**Goal**: Implement conversation UI with messages

**Tasks**:
1. Create `frontend/components/chat/ChatMessages.tsx`:
   - Render user and assistant messages
   - Different styling per role
   - Show tool call results inline
   - Auto-scroll to latest
2. Create `frontend/components/chat/ChatInput.tsx`:
   - Text input with send button
   - Loading/disabled state during send
   - Enter to send, Shift+Enter for newline
3. Create `frontend/lib/chat-api.ts`:
   - `sendMessage(message, conversationId)`
   - `getConversations()`
   - `getConversationHistory(id)`
4. Integrate API client with components
5. Test message flow end-to-end

**Outputs**: Message list, input components, API client

---

### Phase 7: Conversation Persistence

**Goal**: Enable conversation continuity across sessions

**Tasks**:
1. Store conversation_id in session/localStorage
2. Load conversation history on drawer open
3. Handle new conversation vs existing
4. Display conversation list (optional for MVP)
5. Test persistence:
   - Close browser, reopen, verify history
   - Server restart, verify history
6. Implement message pagination for long conversations

**Outputs**: Persistent conversations, history loading

---

### Phase 8: Error Handling & Polish

**Goal**: Graceful degradation and user experience polish

**Tasks**:
1. Implement error handling:
   - AI service unavailable → Show retry message
   - Token expired → Prompt re-login
   - Task not found → Suggest list tasks
2. Add loading states:
   - Typing indicator while AI responds
   - Loading skeleton for history
3. Add animations (optional):
   - Drawer slide animation
   - Message fade-in
4. Test error scenarios
5. Final acceptance testing per spec

**Outputs**: Error handling, loading states, polished UX

## Dependencies & Execution Order

```
Phase 1 (DB Schema)
    ↓
Phase 2 (MCP Tools) ← depends on models
    ↓
Phase 3 (Agent) ← depends on tools
    ↓
Phase 4 (API Endpoint) ← depends on agent, models
    ↓
Phase 5 (Chat Button/Drawer) ← can start parallel with Phase 4
    ↓
Phase 6 (Message Components) ← depends on API endpoint
    ↓
Phase 7 (Persistence) ← depends on components
    ↓
Phase 8 (Polish) ← depends on all above
```

**Parallel Opportunities**:
- Phase 5 (frontend UI shell) can run in parallel with Phases 2-4 (backend)
- Phase 6 can start once API endpoint contract is defined (stub responses)

## Acceptance Criteria

### Functional Validation

- [ ] Add task via chat: "Add buy groceries" → Task created, confirmed in chat
- [ ] List tasks via chat: "Show my tasks" → Task list displayed
- [ ] Complete task via chat: "Mark buy groceries done" → Status updated
- [ ] Update task via chat: "Rename buy groceries to shopping" → Title changed
- [ ] Delete task via chat: "Delete shopping" → Task removed

### Security Validation

- [ ] User A cannot see User B's tasks via chat
- [ ] User A cannot modify User B's tasks via chat
- [ ] Unauthenticated requests return 401
- [ ] Invalid user_id in path returns 403

### Reliability Validation

- [ ] Server restart preserves conversation history
- [ ] Browser refresh preserves current conversation
- [ ] Large conversation (100+ messages) loads correctly

### UX Validation

- [ ] AI confirms actions before execution
- [ ] AI asks clarification for ambiguous requests
- [ ] Error messages are user-friendly
- [ ] Loading indicator shows while AI responds

## Complexity Tracking

> No constitution violations requiring justification.

| Potential Concern | Resolution |
|-------------------|------------|
| OpenAI API latency | Accepted for MVP; optimization deferred |
| ChatKit availability | Alternative: Vercel AI SDK or custom components |
| MCP SDK integration | Falls back to direct function calls if needed |

## Next Steps

1. Run `/sp.tasks` to generate detailed implementation tasks
2. Begin with Phase 1 (Database Schema Extension)
3. Test incrementally after each phase
4. Final validation against spec acceptance criteria

---

**Plan Status**: ✅ Complete - Ready for `/sp.tasks`
